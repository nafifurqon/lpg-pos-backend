# Implementation Plan — Include User In Auth Response

## Overview

| Field               | Value                                                                  |
|---------------------|------------------------------------------------------------------------|
| **Plan ID**         | BE-PLAN-03                                                             |
| **Related Story**   | `2026-02-28 00.00.00-TASK-Include User In Auth Response-LPG-3`        |
| **Author**          | —                                                                      |
| **Date**            | 2026-02-28                                                             |
| **Status**          | Done                                                                   |

## Goal

Add the authenticated user's identity (`id`, `email`, `role`) to the result of all auth endpoints so the frontend can hydrate its auth store in a single round-trip. No entity or migration changes are needed because all required fields already exist on the `User` entity and are present in the JWT payload / service method parameters.

## Scope

### In Scope

- New `AuthResult` type in `src/auth/auth.service.ts`
- Updated `issueTokenPair` private helper: returns `AuthResult` (includes `user` block)
- Updated method return types: `registerWithEmail`, `loginWithEmail`, `loginWithGoogle`, `refreshTokens`
- Frontend type alignment (`AuthResponse`, `User`, `ApiResponse<T>`)
- Frontend API wiring: remove all mocks; real Axios calls with envelope unwrapping
- Frontend Axios client: refresh-with-retry interceptor on 401
- Frontend auth store: consume `AuthResponse`, persist `refreshToken`, async `logout`
- Frontend shop store: wire real `createShop` API call
- Frontend `DashboardPage`: call `GET /dashboard` on mount

### Out of Scope

- `name` field on `User` entity (separate task)
- JWT payload changes (no `name` in token)
- Any database migration

## Affected Files

| File                                          | Change Type | Notes                                                                 |
|-----------------------------------------------|-------------|-----------------------------------------------------------------------|
| `src/auth/auth.service.ts`                    | Modify      | Add `AuthResult` type; update `issueTokenPair` and `refreshTokens`   |
| `frontend/src/types/auth.types.ts`            | Modify      | Replace `AuthResponse`; drop `name`; add `ApiResponse<T>`            |
| `frontend/src/types/shop.types.ts`            | Modify      | Add `updatedAt: string`                                               |
| `frontend/src/api/auth.api.ts`                | Modify      | Remove mocks; wire real calls; add `refreshTokens`, `logoutApi`      |
| `frontend/src/api/shop.api.ts`                | Modify      | Remove mock; wire `POST /shops`                                       |
| `frontend/src/api/client.ts`                  | Modify      | Change localStorage key; add refresh-with-retry on 401               |
| `frontend/src/store/auth.store.ts`            | Modify      | Add `refreshToken` state; consume `AuthResponse`; async `logout`     |
| `frontend/src/pages/dashboard/DashboardPage.tsx` | Modify   | Add `useEffect` calling `GET /dashboard` on mount                    |

## Implementation Steps

1. **Backend — AuthResult type** — Add `AuthResult = TokenPair & { user: { id, email, role } }` to `auth.service.ts`
2. **Backend — issueTokenPair** — Update return type to `Promise<AuthResult>`; include `user: { id: userId, email, role }` in the returned object
3. **Backend — refreshTokens** — Change return type to `Promise<AuthResult>`; construct `user` block from existing `userId`, `email`, `role` params (no extra DB call)
4. **Frontend — types** — Update `AuthResponse`; remove `name` from `User`; add `ApiResponse<T>`
5. **Frontend — shop types** — Add `updatedAt: string`
6. **Frontend — auth.api.ts** — Remove all mocks; call real endpoints; add `refreshTokens` and `logoutApi` with `Authorization: Bearer <refreshToken>` header override
7. **Frontend — shop.api.ts** — Remove mock; call `POST /shops`; unwrap `data.result`
8. **Frontend — client.ts** — Change localStorage key to `access_token`; add 401 interceptor: refresh via raw `axios.post` → retry once → redirect on second failure
9. **Frontend — auth.store.ts** — Add `refreshToken` state; update all actions; make `logout` async (calls `logoutApi` before clearing state)
10. **Frontend — DashboardPage** — Add `useEffect` calling `apiClient.get('/dashboard')` on mount

## API Changes

| Method | Path            | Auth Required | Change                                           |
|--------|-----------------|---------------|--------------------------------------------------|
| POST   | `/auth/register`| No            | `result` now includes `user: { id, email, role }`|
| POST   | `/auth/login`   | No            | Same                                             |
| POST   | `/auth/google`  | No            | Same                                             |
| POST   | `/auth/refresh` | Refresh token | Same                                             |

## Environment Variable Changes

None.

## Rollback Plan

- Revert `issueTokenPair` to return `TokenPair` (remove `user` block)
- Revert `refreshTokens` return type
- Frontend: revert API and store files to mock-based versions

## Verification Checklist

- [x] `POST /auth/register` returns `{ message, result: { access_token, refresh_token, user: { id, email, role } } }`
- [x] `POST /auth/refresh` returns same shape
- [x] Frontend login → `localStorage` has `access_token` + `refresh_token`; store has `user.id`, `user.email`, `user.role`
- [x] Expire access token → 401 triggers silent refresh + retry
- [x] Logout → `POST /auth/logout` fires; localStorage cleared; redirect to `/login`
- [x] `GET /dashboard` fires on `DashboardPage` mount
- [x] `npx tsc --noEmit` passes in `backend/` and `frontend/`
- [x] Related story `LPG-3` marked `Done` in `docs/stories/`
